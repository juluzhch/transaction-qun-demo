package com.example.mybatis.demo.service;

/**
 * QunTransactionTest
 *
 * @author zhangchao01
 * @date 2021/11/11
 */
public class QunTransactionTest {

    //version 变小验证
      // 1:同一个操作，执行快慢不同 逐级加锁导致后一个开始执行的，先提交
           //修改群成员  A: 修改成员， 修改群 提交  B:修改成员，修改群，提交 。 A B修改不同的群成员
            //要求 A 记录时间戳，修改成员1 ， B记录时间戳 修改成员2  B修改群 B提交A修改群 A提交 。

      //2:不同操作
         // A ：修改群成员，修改群   B :修改群  。  B在A后执行，但在A前提交。
      //insert 操作。
    //验证结果--确实可以回退version

    //计数验证
        //幻读问题--A: insert  member ,  count member   update qun ,   B: count  member ,update qun
        //A: 添加成员，更新计数。 B：更新计数
        //要求： B的count 在A提交事务前， B的update qun 在A提交事务后。
        //spring 事务的默认级别。
     //验证结果--read_repeat 不产生幻读，但读取的计数是错误的，新插入的记录没有计算在内
     //read_commit ,会产生幻读。



    //死锁验证
      //1:先后更新不同的表导致死锁
      //A:解散群 ：更新群 ，更新群成员  B:更新群成员，更新群  （修改成员名称）
       //要求： A更新群  B更新群成员， A更新群成员  B 更新群
   //验证结果-产生死锁




    //调整后的方案验证
    //1: 用数据库时间查看能否解决版本变小问题--不能
       //更新不同成员，相互间无争用问题。 先执行的可能提交事务反而晚，sql中的数据库时间==事务提交时间还是sql执行时间？应该时执行时间。
       //模拟
       //A: 更新成员 1,  B更新成员2
       //要求  A更新，B更新 B提交 A提交。

    //2：计数调整
    // 事务丢失更新问题验证
      //A 更新成员-1 ，计数更新 B:更新成员2 ,计数更新。
      //A 更新成员-1 ，计数更新 B:更新成员1 ,计数更新。
      // 要求 A 查询成员，B查询成员，A更新成员，B更新成员  A更新计数，B更新计数。
      // 理论上B的更新应该会失败。

}
